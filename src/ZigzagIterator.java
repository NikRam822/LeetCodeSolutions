import javax.swing.text.html.HTMLDocument;
import java.util.*;

/*Описание задачи: Итератор с "зигзагообразным" обходом (Zigzag Iterator)
Даны два вектора (списка) целых чисел v1 и v2. Нужно реализовать итератор, который будет поочерёдно возвращать элементы из этих векторов в порядке "зигзаг" — сначала первый элемент из v1, затем первый из v2, потом второй из v1, второй из v2 и так далее.

Если один из векторов закончился раньше другого, итератор должен продолжать обход оставшихся элементов второго вектора.

Класс ZigzagIterator должен иметь:
Конструктор ZigzagIterator(List<Integer> v1, List<Integer> v2) — инициализирует итератор на двух векторах.

Метод boolean hasNext() — возвращает true, если итератор ещё имеет элементы для возврата, иначе false.

Метод int next() — возвращает текущий элемент итератора и переводит итератор к следующему элементу.

Примеры

Пример 1
Input:
v1 = [1, 2], v2 = [3, 4, 5, 6]
Output:
[1, 3, 2, 4, 5, 6]

Объяснение:
next() возвращает элементы поочередно: 1 (из v1), 3 (из v2), 2 (из v1), 4 (из v2), затем остаток из v2 — 5, 6.

Пример 2
Input:
v1 = [1], v2 = []
Output:
[1]

Пример 3
Input:
v1 = [], v2 = [1]
Output:
[1]

Ограничения
0 <= v1.length, v2.length <= 1000

Общая длина v1.length + v2.length не превышает 2000

Элементы векторов — целые числа в диапазоне от -2^31 до 2^31 - 1*/

/**
 * Решение мое, оно не крутое, так как мы все элеемнты складываем в очередь. Обычно итераторы работают линиво и заранее ничего не деалеют + много логики в контрукторе, что неправильно.
 *
 * Создали кучу интов, в конструкторе идем циклом по элементам:
 * Перед циклом создали count - счетчик, который контролирует, количество пройденных эелемнтов, i и j - итераторы для v1 и v2 соответсвенно.
 * В цикле проверяем сначала для v1 (так как zig-zag начинается с него) потом такое же условие для v2: если текущий итератор (i или j, в зависимости от текущей проверки),
 * меньше соотсветсвующего массива (v1 для i и v2 для j) - мы добавляем элемент в очередь, увеличиваем итератор и счетчик элеемнтов.
 * Таким образом по выходу из конструткора, у нас будет очередь, в который элементы уже в нужном порядке.
 *
 * Так как очередь уже все в себе храняит, в hasNext() мы просто выводим !queue.isEmpty, а в next возвращаем queue.poll().
 * Таким образом, если очередь не пуста - будет тру,  а при некст - выбрасываем элемент из очереди и возвращаем его.
 *
 */
/*public class ZigzagIterator {
    List<Integer> v1, v2;

    Queue<Integer> queue;

    // v1 = [1, 2], v2 = [3, 4, 5, 6]
    // Конструктор и поля для хранения векторов и состояния итератора
    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        this.queue = new LinkedList<>();
        this.v1 = v1;
        this.v2 = v2;

        int count = 0;
        int i = 0;
        int j = 0;
        while (count !=v1.size() + v2.size()) {

            if (i < v1.size()) {
                queue.add(v1.get(i));
                i++;
                count++;
            }

            if (j < v2.size()) {
                queue.add(v2.get(j));
                j++;
                count++;
            }
        }

        System.out.println(queue);

    }

    *//**
 * Проверяет, остались ли еще элементы для обхода
 *
 * @return true, если есть следующий элемент, иначе false
 *//*
    public boolean hasNext() {
        // TODO: реализовать метод
        return !queue.isEmpty();
    }

    *//**
 * Возвращает следующий элемент итератора и передвигает внутренний указатель
 *
 * @return следующий элемент
 *//*
    public int next() {

        // TODO: реализовать метод
        return queue.poll(); // заглушка
    }
}*/

import java.util.*;

/**
 * НЕ МОЕ
 * Очень похоже на мое, но это трушный ленивый подход.
 *
 * Сздаем не очередь элементов (как у меня), а очередь итераторов.
 * В конструкторе добавляем итераторы обоих массивов (если массивы не пусты)
 *
 * затем в hasNext возвращаем  !queue.isEmpty() (также, как и уменя), типо если итератор в очереди - итерируемся.
 * В next() доатсаем из очереди итератор, если у итератора есть слеующий элеемнт - добавляем итератор, в очередь
 * (таким способом в очереди всегда два элемента и в разном порядке, идя прикольная)
 * Выводим элемент, который достали до смещнеия курсорв (нелья сразу в ретюрн положить current.next(), ПОТОМУ ЧТО В ТАКОМ СЛУЧАЕ ЭЛЕЕМНТ СО СДВИНУТЫМ КУРСОРОМ ПОЛЕТИТ В ОЧЕРЕДЬ, И КОГДА МЫ БУДЕМ ДОСТАВАТЬ - ВСЕ ПОЛЕТИТ)
 *
 * ЕСли просытми словами, в методе некст - мы достаем элеемнт из очереди, у элеемнта достаем значение, смещаяя курсор на следующий и проверям, что у текущего элемента есть следующий, чтобы курсор не смотрел в пустоту.
 */
/*public class ZigzagIterator {
    private Queue<Iterator<Integer>> queue;

    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        queue = new LinkedList<>();
        if (!v1.isEmpty()) {
            queue.offer(v1.iterator());
        }
        if (!v2.isEmpty()) {
            queue.offer(v2.iterator());
        }
    }

    public boolean hasNext() {
        return !queue.isEmpty();
    }

    public int next() {
        Iterator<Integer> current = queue.poll();
        int result = current.next();
        if (current.hasNext()) {
            queue.add(current);
        }
        return result;
    }
}*/

/*Хранить два индекса (по каждому вектору) и флаг, чей сейчас ход.
В next() возвращать элемент из текущего вектора, переключать ход на другой, учитывая границы и проверяя, не закончился ли вектор.*/
import java.util.List;

public class ZigzagIterator {
    private List<Integer> v1, v2;
    private int i = 0, j = 0;
    private boolean turnV1 = true;  // чей ход

    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {
        this.v1 = v1;
        this.v2 = v2;
    }

    public boolean hasNext() {
        return i < v1.size() || j < v2.size();
    }

    public int next() {
        if (!hasNext()) {
            throw new java.util.NoSuchElementException();
        }
        if ((turnV1 && i < v1.size()) || j >= v2.size()) {
            turnV1 = false;
            return v1.get(i++);
        } else {
            turnV1 = true;
            return v2.get(j++);
        }
    }
}


