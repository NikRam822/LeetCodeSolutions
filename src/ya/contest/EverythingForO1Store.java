package ya.contest;

import java.io.*;
import java.util.ArrayDeque;
import java.util.Deque;

/**
 * Не все тесты прошли по времени
 *
 * В магазине «Всё за O(1)» есть две кассы и много посетителей. Вам предстоит смоделировать очереди в эти кассы по записанной истории работы магазина.
 *
 * Вам в хронологическом порядке даны события, закодированные следующими символами:
 *
 * a — в конец очереди в первую кассу встал очередной посетитель;
 * b — в конец очереди во вторую кассу встал очередной посетитель;
 * A — в первой кассе обслужили первого посетителя в очереди;
 * B — во второй кассе обслужили первого посетителя в очереди;
 * > — первая касса закрылась;
 * ] — вторая касса закрылась;
 * < — первая касса открылась;
 * [ — вторая касса открылась.
 * Когда касса закрывается, все люди из очереди к этой кассе в обратном порядке, начиная с последнего, переходят в конец другой очереди. То есть первым переходит человек, стоявший последним, затем человек, стоявший предпоследним, и так далее. В итоге последним в получившейся очереди будет стоять тот, кто был первым в очереди к только что закрывшейся кассе.
 *
 * Когда закрытая касса открывается, люди в очереди к другой кассе, начиная с последнего, переходят в нее, если их место в новой очереди окажется строго меньше текущего. Стоявший последним становится первым в новой очереди, стоявший предпоследним становится вторым и так далее.
 *
 * Список событий корректен, то есть:
 *
 * Открываются только закрытые кассы;
 * Закрываются только открытые кассы;
 * Посетители не встают в очереди к закрытым кассам;
 * Закрытые кассы не пытаются обслуживать посетителей;
 * Кассы не обслуживают посетителей, если очереди к ним пустые;
 * В каждый момент времени работает хотя бы одна касса.
 * Посетители нумеруются с единицы в порядке их появления в списке событий. В начальный момент обе кассы открыты и обе очереди пусты.
 *
 * Формат ввода
 * В первой строке входных данных содержится натуральное число
 * n
 * (2<=n<=10^7) - количество событий.
 *
 * Во второй строке содержится
 * n символов, описывающих события согласно приведённым выше обозначениям.
 * Гарантируется, что во входных данных содержится хотя бы один запрос обработки запроса
 * Формат вывода
 * В единственной строке выведите для каждой записи обслуживания последнюю цифру номера обслуженного посетителя. Ответы выводите в порядке выполнения запросов обслуживания, не используйте никаких разделителей.
 *
 * Пример 1
 * Ввод
 *
 * 15
 * aaabA>bBBb<BBAa
 * Вывод
 *
 * 143256
 * Пример 2
 * Ввод
 *
 * 12
 * aaaaa><AABBB
 * Вывод
 *
 * 12543
 */
public class EverythingForO1Store {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = Integer.parseInt(br.readLine());
        String events = br.readLine();

        Deque<Integer> q1 = new ArrayDeque<>();
        Deque<Integer> q2 = new ArrayDeque<>();
        boolean closed1 = false;
        boolean closed2 = false;
        int nextId = 1;
        StringBuilder result = new StringBuilder();

        for (int i = 0; i < n; i++) {
            char c = events.charAt(i);
            if (c == 'a') {
                if (!closed1) q1.addLast(nextId++);
            } else if (c == 'b') {
                if (!closed2) q2.addLast(nextId++);
            } else if (c == 'A') {
                if (!closed1 && !q1.isEmpty()) {
                    int served = q1.removeFirst();
                    result.append(served % 10);
                }
            } else if (c == 'B') {
                if (!closed2 && !q2.isEmpty()) {
                    int served = q2.removeFirst();
                    result.append(served % 10);
                }
            } else if (c == '>') {
                // close cash 1
                closed1 = true;
                while (!q1.isEmpty()) {
                    q2.addLast(q1.removeLast());
                }
            } else if (c == ']') {
                // close cash 2
                closed2 = true;
                while (!q2.isEmpty()) {
                    q1.addLast(q2.removeLast());
                }
            } else if (c == '<') {
                // open cash 1
                closed1 = false;
                while (!q2.isEmpty() && q1.size() < q2.size() - 1) {
                    q1.addLast(q2.removeLast());
                }
            } else if (c == '[') {
                // open cash 2
                closed2 = false;
                while (!q1.isEmpty() && q2.size() < q1.size() - 1) {
                    q2.addLast(q1.removeLast());
                }
            }
        }

        bw.write(result.toString());
        bw.flush();
    }
}
