package dt.tasks;

import java.util.Arrays;
import java.util.HashMap;

/*

Есть текст T и строка S. Нужно найти индекс первого вхождения строки S в текст T. Перестановка символов неважна.

То есть по сути нужно найти индекс первого вхождение одной из всех возможных перестановок строки S в тексте T.

        Пример:
T: Я шёл по улице, капал дождь, было пасмурно, но моё настроение было на высоте, ведь я решил эту алгоритмическую задачу!

S: жоддь

Ответ: 22

Пояснение: индексация текста с нуля. Найдено слово дождь, так как существует перестановка жоддь -> дождь. Слово дождь в тексте начинается с 22 индекса
*/


public class SearchIndex {
    /**
     * НЕ РАБОТАЕТ ДЛЯ СЛУЧАЕВ, КОГДА s - НЕ ЯВЛЯЕТСЯ СЛОВОМ. НУЖНО УБРАТЬ ИДЕИ СПЛИТОВ ДЛЯ ДРУГИХ СЛУЧАЕВ.
     * <p>
     * Прикольное решение. Сумма кодов символов в строке одинаковая вне зависимости от порядка - поэтому просто используем этот, как контрольную сумму.
     * Решение работает по принципы иквелс и хэшкод. Сначала проверяем хэш-сумму, если совпала - сравниваем элементы.
     * Сплитим строку, отделяя пробелы и знаки препинания с помощью регулярки
     * Идем по массиву строк, если сумма символов очередной строки равна сумме символов входно стрки - делаем проверку.
     * Если остортирванные строки равны - возврщвем индекс. (вторая проверка нужна, что коллизии чекать, типо суммы индексов таких строк равны: гожеь == жоддь == дождь)
     * <p>
     * P.S. Если искомая строка - не одна строка, то сплит не подходит. Нужно искать иначе.
     * Тогда можно сохранить в хэшсет коды символов и если символ входит в хэшсет - суммирем его во временную сумму,
     * делаем это до тех пор, пока сумма не сравняется с нашей, но если встретили символ не из хэшсета - очищаем сумму, идем дальше.
     */
    /*public int searchIndex(String text, String s) {
        int sumS = s.chars().sum();

        String[] t = text.split("[\\s,;:.!?-]+");

        for (String str : t) {
            if(str.chars().sum() == sumS){
                char[] ts = str.toCharArray();
                char[] ss = s.toCharArray();
                Arrays.sort(ts);
                Arrays.sort(ss);
                if(Arrays.equals(ts, ss)) {
                    return text.indexOf(str);
                }
            }
        }
        return -1;
    }*/

    /**
     * Основная идея:
     *
     * Все эелементы искомой строки пишем в мапу, где ключ - символ, значение - сколько раз встречается.
     * Создаем временную мапу, которую мы будем менять в процессе работы алгоритма (копия мапы).
     * Создаем сртингбилдер, куда булем складывать найденную строку. (можно сделать просто интом, запоминая идекс первого элемента, но нужно доп услове делать, решил так)
     *
     * Идем по строке, если очередной символ есть в временной Мапе - сохраняем символ в result, уменьшаем счетчик в мапе. Если счетчик 0 - удаляем элемент из мапы.
     * Таким убразом, если встретили искомую подстроку - временная мапа будет пуста и мы выведем индекс.
     *
     * Если очередной символ в строке не входит в мапу - мы обнуляем result и пересоздаем мапу (так как она могла меняться)
     *
     * P.S. Много памяти жрет из-за мап, но надеемся на гарбач-коллектор, что он все ненужные ссылки подберет.
     */
    public int searchIndex(String text, String s) {

        HashMap<Character, Integer> map = new HashMap<>();
        s.chars().forEach(i -> {
            Integer count = map.get((char) i);
            if (count != null) {
                map.replace((char) i, count + 1);
            } else {
                map.put((char) i, 1);
            }
        });

        HashMap<Character, Integer> tempMap = new HashMap<>(map);
        StringBuilder result = new StringBuilder();
        for (char ch : text.toCharArray()) {
            Integer count = tempMap.get(ch);
            if (count != null) {
                result.append(ch);
                count--;
                if (count == 0) {
                    tempMap.remove(ch);
                } else {
                    tempMap.replace(ch, count);
                }

            } else {
                result.setLength(0);
                tempMap = new HashMap<>(map);
            }

            if (tempMap.isEmpty()) {
                return text.indexOf(result.toString());
            }
        }

        return -1;
    }
}
